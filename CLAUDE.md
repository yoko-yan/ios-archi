# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is a Japanese iOS application playground project (`ios-archi`) used for technical experimentation. It intentionally contains both modern and legacy technologies for learning purposes. The app uses MVVM + Layered Architecture with multi-module structure via SPM.

## Project Structure

### Multi-Module Architecture

The project uses Swift Package Manager for modularization:

- **`Package/`**: Contains all feature modules and shared libraries
  - **`Core`**: Foundation module with DI container (`InjectedValues`) and build helpers
  - **`Analytics`**: Protocol definitions for analytics services
  - **`AnalyticsImpl`**: Firebase Analytics implementation
  - **`AppFeature`**: Main feature module with layered architecture:
    - `Domain/`: Use cases (e.g., `GetSeedFromImageUseCase`, `SynchronizeWithCloudUseCase`)
    - `Data/`: Data layer with Repository, DataSource, and Request
    - `UI/`: SwiftUI views organized by feature (e.g., `RootView/`, `ItemDetail/`, `WorldList/`)
    - `Model/`: Domain models
    - `Extension/`: Swift extensions
    - `CodeGenerated/`: Auto-generated code from Sourcery (mocks, DI code)

- **`App/ios-archi/`**: Main application target
  - Contains the app entry point (`ios_archiApp.swift`) and `AppDelegate`
  - Uses XCConfig files in `XCConfigs/` for build configuration
  - Links to Package modules as dependencies

### Workspace Structure

- `ios-archi.xcworkspace`: Main workspace (combines CocoaPods and SPM)
- `App/ios-archi.xcodeproj`: Application project
- Uses both CocoaPods (SwiftLint, SwiftFormat, Sourcery) and SPM (feature modules)

## Build and Development Commands

### Initial Setup

```bash
make bootstrap
```

This will:
1. Install correct Ruby version via rbenv
2. Install bundler dependencies (CocoaPods, Fastlane)
3. Install CocoaPods dependencies
4. Open the workspace

### Building in VS Code

The project uses `xcode-build-server` for VS Code integration. The configuration is in `buildServer.json`:
- Workspace: `ios-archi.xcworkspace`
- Scheme: `ios-archi`

### Manual Build Commands

```bash
# Build the workspace
xcodebuild -workspace ios-archi.xcworkspace -scheme ios-archi build

# Build for testing
xcodebuild -workspace ios-archi.xcworkspace -scheme ios-archi build-for-testing

# Run tests
xcodebuild -workspace ios-archi.xcworkspace -scheme ios-archi test
```

### Code Quality Tools

```bash
# Run SwiftLint
bundle exec Pods/SwiftLint/swiftlint

# Auto-fix SwiftLint issues
bundle exec Pods/SwiftLint/swiftlint --fix

# Run SwiftFormat
bundle exec Pods/SwiftFormat/CommandLineTool/swiftformat .

# Generate code with Sourcery (mocks and DI)
bundle exec Pods/Sourcery/bin/sourcery --config .sourcery.yml
```

### Dependency Management

```bash
# Install/update CocoaPods
bundle exec pod install

# Update Swift Package dependencies
# (done via Xcode or xcodebuild -resolvePackageDependencies)
```

## Architecture Patterns

### Dependency Injection

The project uses a custom property-wrapper-based DI container (`Core/InjectedValues.swift`):

```swift
// Define an injection key
extension InjectedValues {
    var myService: MyService {
        get { Self[MyServiceKey.self] }
        set { Self[MyServiceKey.self] = newValue }
    }
}

private struct MyServiceKey: InjectionKey {
    static var currentValue: MyService = MyServiceImpl()
}

// Use in code
@Injected(\.myService) var myService
```

### Code Generation with Sourcery

Two main protocols trigger code generation:
- **`AutoMockable`**: Generates test mocks in `CodeGenerated/AutoGeneratedMocks.swift`
- **`AutoInjectable`**: Generates DI registration code in `CodeGenerated/AutoInjectableValues.swift`

Configuration: `.sourcery.yml` defines source paths and templates

### Testing

- **Framework**: Quick/Nimble for BDD-style tests
- **Location**: `Package/Tests/AppFeatureTests/`
- **Naming**: Tests use `Spec` suffix (e.g., `RootViewModelSpec.swift`)
- **Dependencies**: swift-dependencies framework for dependency management in tests
- **Mocks**: Auto-generated via Sourcery from `AutoMockable` protocol

Example test structure:
```swift
class MyViewModelSpec: AsyncSpec {
    override class func spec() {
        describe("feature") {
            context("when condition") {
                it("should behavior") {
                    expect(result) == expected
                }
            }
        }
    }
}
```

## Important Configuration Files

- **`.swiftlint.yml`**: Comprehensive SwiftLint rules with many opt-in rules enabled
- **`.swiftformat`**: SwiftFormat configuration (4-space indent, alphabetized imports)
- **`.sourcery.yml`**: Sourcery code generation configuration
- **`Package/Package.swift`**: SPM package definition with strict concurrency enabled
- **`Podfile`**: CocoaPods dependencies (SwiftLint, SwiftFormat, Sourcery only)
- **`App/ios-archi/XCConfigs/`**: XCConfig files for build settings (Base, Debug, Release, Local)

## Technologies in Use

- iOS 17+, Swift 5.9+
- SwiftUI for UI
- Combine and Swift Concurrency
- CoreData (check `App/ios-archi/Resources/`)
- Firebase (Analytics, Crashlytics)
- CloudKit (for data synchronization)
- VisionFramework
- WebKit
- Quick/Nimble for testing
- swift-dependencies for DI in tests

## Special Notes

- Code generation targets are excluded from SwiftLint (see `.swiftlint.yml` excluded paths)
- Strict concurrency checking is enabled in `Package.swift`
- The project uses both trailing closures and explicit closure syntax based on context
- Japanese comments may appear in code and configuration files
- Local configuration is in `Local.xcconfig` (not in git, see `Local.xcconfig.sample`)
