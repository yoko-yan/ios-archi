# AGENTS.md

This file provides guidance for AI coding agents working with this iOS application codebase.

## Language Preference

**IMPORTANT: Always respond in Japanese (日本語) when interacting with this codebase.**

This is a Japanese development project, and all explanations, suggestions, and communications should be provided in Japanese unless explicitly asked otherwise. Japanese comments may appear throughout the codebase - this is intentional for this learning project.

## Project Overview

This is a Japanese iOS application playground project (`ios-archi`) used for technical experimentation. It intentionally contains both modern and legacy technologies for learning purposes. The app uses MVVM + Layered Architecture with multi-module structure via SPM.

## Setup

### Initial Setup

```bash
# Resolve dependencies and open project
make bootstrap
```

### Build Commands

```bash
# Build the project
xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi build

# Build for testing
xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi build-for-testing

# Run tests
xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi test
```

### Code Quality Tools

```bash
# Run SwiftLint
make lint

# Auto-fix SwiftLint issues
make lint-fix

# Run SwiftFormat
make format

# Generate code with Sourcery (mocks and DI)
make sourcery
```

## Architecture Guidelines

### Module Structure

- **`Package/Sources/Core/`**: Foundation module with DI container (`InjectedValues`) and build helpers
- **`Package/Sources/Analytics/`**: Analytics protocol definitions
- **`Package/Sources/AnalyticsImpl/`**: Firebase Analytics implementation
- **`Package/Sources/AppFeature/`**: Main feature module with layered architecture
  - `Domain/`: Use cases (e.g., `GetSeedFromImageUseCase`, `SynchronizeWithCloudUseCase`)
  - `Data/`: Repository, DataSource, Request implementations
  - `UI/`: SwiftUI views organized by feature (e.g., `RootView/`, `ItemDetail/`, `WorldList/`)
  - `Model/`: Domain models
  - `Extension/`: Swift extensions
  - `CodeGenerated/`: Auto-generated code from Sourcery (mocks, DI code) - do not edit manually

- **`App/ios-archi/`**: Main application target
  - Contains the app entry point (`ios_archiApp.swift`) and `AppDelegate`
  - Uses XCConfig files in `XCConfigs/` for build configuration
  - Links to Package modules as dependencies

### Project Structure

- `App/ios-archi.xcodeproj`: Application project
- `Tools/Package.swift`: Development tools (SwiftLint, SwiftFormat, Sourcery) via SPM
- Uses SPM for both feature modules and development tools

### Layered Architecture

Follow MVVM + Layered Architecture:

1. **UI Layer** (`UI/`): SwiftUI views and ViewModels
2. **Domain Layer** (`Domain/`): Use cases containing business logic
3. **Data Layer** (`Data/`): Repository and DataSource implementations

**Dependencies flow**: UI → Domain → Data

### Dependency Injection

Use the custom property-wrapper-based DI container:

```swift
// Define injection key in InjectedValues
extension InjectedValues {
    var myService: MyService {
        get { Self[MyServiceKey.self] }
        set { Self[MyServiceKey.self] = newValue }
    }
}

private struct MyServiceKey: InjectionKey {
    static var currentValue: MyService = MyServiceImpl()
}

// Use in code
@Injected(\.myService) var myService
```

For test dependencies, mark protocols with `AutoInjectable`:

```swift
protocol MyService: AutoInjectable {
    func doSomething()
}
```

### Code Generation with Sourcery

Use these protocols to trigger auto-generation:

- **`AutoMockable`**: Generates test mocks in `CodeGenerated/AutoGeneratedMocks.swift`
- **`AutoInjectable`**: Generates DI registration in `CodeGenerated/AutoInjectableValues.swift`

Run `make sourcery` after adding these protocols.

## Code Style

### Swift Style

- **Indentation**: 4 spaces (configured in `.swiftformat`)
- **Imports**: Alphabetically sorted (enforced by SwiftFormat)
- **Naming**: Follow Swift API Design Guidelines
- **Concurrency**: Prefer Swift Concurrency (async/await) over Combine for new code
- **Access Control**: Use the most restrictive access level appropriate

### SwiftLint Rules

This project has comprehensive SwiftLint rules (`.swiftlint.yml`) with many opt-in rules enabled. Always run `make lint` before committing.

Key rules:
- Strict concurrency checking enabled
- Prefer explicit type annotations where clarity is needed
- Avoid force unwrapping
- Use `weak self` in closures to prevent retain cycles

### File Organization

- Group related files in feature-based directories
- Keep ViewModels close to their corresponding Views
- Place shared utilities in appropriate modules (Core, Extensions)

### Special Coding Considerations

- Strict concurrency checking is enabled in `Package.swift`
- The project uses both trailing closures and explicit closure syntax based on context
- CoreData resources are located in `App/ios-archi/Resources/`

## Testing Guidelines

### Test Framework

Use **Quick/Nimble** for BDD-style tests:

```swift
class MyViewModelSpec: AsyncSpec {
    override class func spec() {
        describe("ViewModel") {
            context("when action is performed") {
                it("should update state correctly") {
                    expect(viewModel.state) == .expected
                }
            }
        }
    }
}
```

### Test Location

- Unit tests: `Package/Tests/AppFeatureTests/`
- UI tests: `App/ios-archiUITests/`

### Test Naming

- Test files use `Spec` suffix (e.g., `RootViewModelSpec.swift`)
- Use descriptive test names in Japanese if needed

### Dependencies in Tests

Use `swift-dependencies` framework with auto-generated mocks:

```swift
withDependencies {
    $0.myService = MyServiceMock()
} operation: {
    // Test code
}
```

### Running Tests

```bash
# Run all tests
xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi test

# Run specific test
xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi test -only-testing:AppFeatureTests/MyViewModelSpec
```

## Git Workflow

### Commit Messages

Write clear, concise commit messages in Japanese:

```
機能追加: ユーザー認証機能を実装

- ログイン画面の追加
- トークン管理の実装
- エラーハンドリングの追加
```

### Before Committing

1. Run code quality checks:
   ```bash
   make lint
   make format
   make sourcery  # if protocols changed
   ```

2. Run tests:
   ```bash
   xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi test
   ```

3. Verify build:
   ```bash
   xcodebuild -project App/ios-archi.xcodeproj -scheme ios-archi build
   ```

### Pull Request Guidelines

- Write PR title and description in Japanese
- Include test plan in PR description
- Ensure all CI checks pass
- Request review from team members

## Important Considerations

### Code Generation Targets

- **Never manually edit** files in `CodeGenerated/` directories
- These files are excluded from SwiftLint (see `.swiftlint.yml`)
- Regenerate using `make sourcery` when needed

### XCConfig Files

- Build settings are managed via XCConfig files in `App/ios-archi/XCConfigs/`
- Local configuration uses `Local.xcconfig` (not in git, see `Local.xcconfig.sample`)

### Firebase Configuration

- `GoogleService-Info.plist` contains Firebase configuration
- Keep sensitive information in `Local.xcconfig` (not committed)

### VS Code Development

The project uses `xcode-build-server` for VS Code integration:
- Configuration: `buildServer.json`
- Project: `App/ios-archi.xcodeproj`
- Scheme: `ios-archi`

## Technologies Stack

### Primary Technologies

- **Language**: Swift 5.9+
- **iOS Version**: iOS 17+
- **UI Framework**: SwiftUI
- **Architecture**: MVVM + Layered Architecture
- **Module System**: Swift Package Manager
- **Dependency Management**: Custom DI Container + swift-dependencies

### Key Libraries

- **Testing**: Quick/Nimble
- **Analytics**: Firebase Analytics
- **Crash Reporting**: Firebase Crashlytics
- **Data Persistence**: CoreData
- **Cloud Sync**: CloudKit
- **Vision**: VisionFramework

### Development Tools

- **Linting**: SwiftLint (via SPM)
- **Formatting**: SwiftFormat (via SPM)
- **Code Generation**: Sourcery (via SPM)
- **Build Configuration**: XCConfig files

## Common Tasks

### Adding a New Feature

1. Create feature directory in `Package/Sources/AppFeature/UI/FeatureName/`
2. Implement ViewModel following MVVM pattern
3. Create use cases in `Domain/` if business logic is complex
4. Implement data layer in `Data/` if data access is needed
5. Add tests in `Package/Tests/AppFeatureTests/`
6. Run `make sourcery` if new protocols are marked with `AutoMockable`

### Adding a New Dependency

1. Update `Package/Package.swift` with new dependency
2. Resolve packages in Xcode
3. Update this documentation if significant

### Troubleshooting Build Issues

1. Clean build folder: `xcodebuild clean -project App/ios-archi.xcodeproj -scheme ios-archi`
2. Reset package cache: `rm -rf ~/Library/Developer/Xcode/DerivedData`
3. Resolve packages: Open Xcode → File → Packages → Resolve Package Versions
4. Regenerate code: `make sourcery`

## References

- [Swift API Design Guidelines](https://www.swift.org/documentation/api-design-guidelines/)
- [SwiftUI Documentation](https://developer.apple.com/documentation/swiftui)
- [Quick/Nimble Documentation](https://github.com/Quick/Quick)
- [swift-dependencies](https://github.com/pointfreeco/swift-dependencies)
